import{e as $,g as I,r as _,a as W,b as X,c as M,d as B,f as K,h as N,i as Q,j as U,k as Y,l as q,m as z,n as Z}from"./@floating-ui_utils@0.2.9-CfPjaTyQ.js";function H(a,i,m){let{reference:n,floating:r}=a;const e=B(i),o=W(i),l=q(o),x=M(i),g=e==="y",d=n.x+n.width/2-r.width/2,s=n.y+n.height/2-r.height/2,f=n[l]/2-r[l]/2;let t;switch(x){case"top":t={x:d,y:n.y-r.height};break;case"bottom":t={x:d,y:n.y+n.height};break;case"right":t={x:n.x+n.width,y:s};break;case"left":t={x:n.x-r.width,y:s};break;default:t={x:n.x,y:n.y}}switch(X(i)){case"start":t[o]-=f*(m&&g?-1:1);break;case"end":t[o]+=f*(m&&g?-1:1);break}return t}const nt=async(a,i,m)=>{const{placement:n="bottom",strategy:r="absolute",middleware:e=[],platform:o}=m,l=e.filter(Boolean),x=await(o.isRTL==null?void 0:o.isRTL(i));let g=await o.getElementRects({reference:a,floating:i,strategy:r}),{x:d,y:s}=H(g,n,x),f=n,t={},c=0;for(let w=0;w<l.length;w++){const{name:u,fn:y}=l[w],{x:h,y:v,data:b,reset:p}=await y({x:d,y:s,initialPlacement:n,placement:f,strategy:r,middlewareData:t,rects:g,platform:o,elements:{reference:a,floating:i}});d=h??d,s=v??s,t={...t,[u]:{...t[u],...b}},p&&c<=50&&(c++,typeof p=="object"&&(p.placement&&(f=p.placement),p.rects&&(g=p.rects===!0?await o.getElementRects({reference:a,floating:i,strategy:r}):p.rects),{x:d,y:s}=H(g,f,x)),w=-1)}return{x:d,y:s,placement:f,strategy:r,middlewareData:t}};async function G(a,i){var m;i===void 0&&(i={});const{x:n,y:r,platform:e,rects:o,elements:l,strategy:x}=a,{boundary:g="clippingAncestors",rootBoundary:d="viewport",elementContext:s="floating",altBoundary:f=!1,padding:t=0}=$(i,a),c=I(t),u=l[f?s==="floating"?"reference":"floating":s],y=_(await e.getClippingRect({element:(m=await(e.isElement==null?void 0:e.isElement(u)))==null||m?u:u.contextElement||await(e.getDocumentElement==null?void 0:e.getDocumentElement(l.floating)),boundary:g,rootBoundary:d,strategy:x})),h=s==="floating"?{x:n,y:r,width:o.floating.width,height:o.floating.height}:o.reference,v=await(e.getOffsetParent==null?void 0:e.getOffsetParent(l.floating)),b=await(e.isElement==null?void 0:e.isElement(v))?await(e.getScale==null?void 0:e.getScale(v))||{x:1,y:1}:{x:1,y:1},p=_(e.convertOffsetParentRelativeRectToViewportRelativeRect?await e.convertOffsetParentRelativeRectToViewportRelativeRect({elements:l,rect:h,offsetParent:v,strategy:x}):h);return{top:(y.top-p.top+c.top)/b.y,bottom:(p.bottom-y.bottom+c.bottom)/b.y,left:(y.left-p.left+c.left)/b.x,right:(p.right-y.right+c.right)/b.x}}const it=a=>({name:"arrow",options:a,async fn(i){const{x:m,y:n,placement:r,rects:e,platform:o,elements:l,middlewareData:x}=i,{element:g,padding:d=0}=$(a,i)||{};if(g==null)return{};const s=I(d),f={x:m,y:n},t=W(r),c=q(t),w=await o.getDimensions(g),u=t==="y",y=u?"top":"left",h=u?"bottom":"right",v=u?"clientHeight":"clientWidth",b=e.reference[c]+e.reference[t]-f[t]-e.floating[c],p=f[t]-e.reference[t],T=await(o.getOffsetParent==null?void 0:o.getOffsetParent(g));let S=T?T[v]:0;(!S||!await(o.isElement==null?void 0:o.isElement(T)))&&(S=l.floating[v]||e.floating[c]);const V=b/2-p/2,D=S/2-w[c]/2-1,R=z(s[y],D),j=z(s[h],D),E=R,F=S-w[c]-j,A=S/2-w[c]/2+V,L=Y(E,A,F),O=!x.arrow&&X(r)!=null&&A!==L&&e.reference[c]/2-(A<E?R:j)-w[c]/2<0,P=O?A<E?A-E:A-F:0;return{[t]:f[t]+P,data:{[t]:L,centerOffset:A-L-P,...O&&{alignmentOffset:P}},reset:O}}}),st=function(a){return a===void 0&&(a={}),{name:"flip",options:a,async fn(i){var m,n;const{placement:r,middlewareData:e,rects:o,initialPlacement:l,platform:x,elements:g}=i,{mainAxis:d=!0,crossAxis:s=!0,fallbackPlacements:f,fallbackStrategy:t="bestFit",fallbackAxisSideDirection:c="none",flipAlignment:w=!0,...u}=$(a,i);if((m=e.arrow)!=null&&m.alignmentOffset)return{};const y=M(r),h=B(l),v=M(l)===l,b=await(x.isRTL==null?void 0:x.isRTL(g.floating)),p=f||(v||!w?[K(l)]:N(l)),T=c!=="none";!f&&T&&p.push(...Q(l,w,c,b));const S=[l,...p],V=await G(i,u),D=[];let R=((n=e.flip)==null?void 0:n.overflows)||[];if(d&&D.push(V[y]),s){const A=U(r,o,b);D.push(V[A[0]],V[A[1]])}if(R=[...R,{placement:r,overflows:D}],!D.every(A=>A<=0)){var j,E;const A=(((j=e.flip)==null?void 0:j.index)||0)+1,L=S[A];if(L)return{data:{index:A,overflows:R},reset:{placement:L}};let O=(E=R.filter(P=>P.overflows[0]<=0).sort((P,k)=>P.overflows[1]-k.overflows[1])[0])==null?void 0:E.placement;if(!O)switch(t){case"bestFit":{var F;const P=(F=R.filter(k=>{if(T){const C=B(k.placement);return C===h||C==="y"}return!0}).map(k=>[k.placement,k.overflows.filter(C=>C>0).reduce((C,J)=>C+J,0)]).sort((k,C)=>k[1]-C[1])[0])==null?void 0:F[0];P&&(O=P);break}case"initialPlacement":O=l;break}if(r!==O)return{reset:{placement:O}}}return{}}}};async function tt(a,i){const{placement:m,platform:n,elements:r}=a,e=await(n.isRTL==null?void 0:n.isRTL(r.floating)),o=M(m),l=X(m),x=B(m)==="y",g=["left","top"].includes(o)?-1:1,d=e&&x?-1:1,s=$(i,a);let{mainAxis:f,crossAxis:t,alignmentAxis:c}=typeof s=="number"?{mainAxis:s,crossAxis:0,alignmentAxis:null}:{mainAxis:s.mainAxis||0,crossAxis:s.crossAxis||0,alignmentAxis:s.alignmentAxis};return l&&typeof c=="number"&&(t=l==="end"?c*-1:c),x?{x:t*d,y:f*g}:{x:f*g,y:t*d}}const at=function(a){return a===void 0&&(a=0),{name:"offset",options:a,async fn(i){var m,n;const{x:r,y:e,placement:o,middlewareData:l}=i,x=await tt(i,a);return o===((m=l.offset)==null?void 0:m.placement)&&(n=l.arrow)!=null&&n.alignmentOffset?{}:{x:r+x.x,y:e+x.y,data:{...x,placement:o}}}}},ot=function(a){return a===void 0&&(a={}),{name:"shift",options:a,async fn(i){const{x:m,y:n,placement:r}=i,{mainAxis:e=!0,crossAxis:o=!1,limiter:l={fn:u=>{let{x:y,y:h}=u;return{x:y,y:h}}},...x}=$(a,i),g={x:m,y:n},d=await G(i,x),s=B(M(r)),f=Z(s);let t=g[f],c=g[s];if(e){const u=f==="y"?"top":"left",y=f==="y"?"bottom":"right",h=t+d[u],v=t-d[y];t=Y(h,t,v)}if(o){const u=s==="y"?"top":"left",y=s==="y"?"bottom":"right",h=c+d[u],v=c-d[y];c=Y(h,c,v)}const w=l.fn({...i,[f]:t,[s]:c});return{...w,data:{x:w.x-m,y:w.y-n,enabled:{[f]:e,[s]:o}}}}}};export{it as a,nt as c,G as d,st as f,at as o,ot as s};
